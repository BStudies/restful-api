<!-- ********************************************************************
     Copyright 2013 Ellucian Company L.P. and its affiliates.
******************************************************************** -->

#RESTful API plugin documentation

##Overview
The restful-api plugin is an implementation designed to conform to the Ellucian API Strategy Document.  It is not intended to implement all optional features of the Document.  It is not intended to provide support for multiple ways to accomplish the same requirements; in general, it implements the recommended approaches specified in the document.

##Details

###Use of conventions
The plugin relies heavily on convention-over-configuration.  A request to a resource named 'things' will be delegated to the 'ThingService'.  De-pluralization of the resource name happens automatically; it is also assumed that there is unique ThingService that can be looked up in the grails application.

###Use of custom media types
The plugin relies on custom media types to specify resource representations.  For requests, the media type in the Content-Type header is used to identify the resource representation in the request body, in order to extract parameters from it to be passed to the resource's service.

Media types used must contain either 'json' or 'xml' in their name.  Any media type with 'json' in the name denotes a format that can be parsed as JSON; any type with 'xml' in the name is a format that is assumed to be parsed as XML.

###Media type of responses
For anything except a 500 response, the plugin will always return a Content-Type header of either 'application/xml' or 'application/json'.  This is intended as a convenience to viewing responses in browsers or other tools without having to configure them for all custom media types used by an API.  You can think of it as the Content-Type of the response identifies the format of the response body, but not the specific type of the representation contained within.

Responses generated by the plugin will always include a 'X-hedtech-Media-Type' header specifying the (versioned) media-type of the representation, e.g., 'application/vnd.hedtech.v0+json' or 'application/vnd.hedtech.minimal-thing.v0+xml'.  Consumers of the API can use the X-hedtech-Media-Type header to determine how to perform data binding on the resource representation returned.

###Media type of error responses
If a request results in an error response, the Media Type will always be 'application/json' or 'application/xml', based on whether the Accept header in the request specified an xml or json format.  If the Accept header could not be understood to request json or xml, then 'application/json' will be used for any data in the return body.

Errors are not considered part of the resource representation, and do not have versioned or custom representations.

###Media type of requests
The plugin uses the Content-Type header to determine the type of the resource representation sent in a request.  It uses the (first) Accept header to determine the type of resource representation that should be used in the response.  The Content-Type and Accept headers on a request are not required to match.

###Unsupported media types
If a request specified an unsupported media type in the Accept header, for a request that returns a reponse body, the plugin will respond with a 406 status code.
If the request specified an unsupported media type in the Content-Type header, for a request that processes a request body, the plugin will respond with a 415 status code.
A delete operation does not return a response body, and will not return a 406 regardless of the Accept header.
Request bodies for list and show operations are ignored (and will not generate a 415) regardless of the Content-Type header.

###Response envelope.
Any response body will be one of the following:

* A representation of a resource
* An array of representations of a resource (either a JSON array, or list representation in xml)
* an empty body

Any 'envelope' information is conveyed in headers.
Currently, the following response headers are supported:

* X-hedtech-totalCount.  Returned with list responses and contains the total count of objects.
* X-hedtech-pageOffset.  Returned with list responses.
* X-hedtech-pageMaxSize. Returned with list responses.
* X-hedtech-Media-Type.  Returned with all (sucess) responses, and contains the exact type of the response.
* X-hedtech-message.  May optionally be returned with any response.  Contains a localized message for the response.
* X-Status-Reason.  Optionally returned with a 400 response to provide additional information on why the request could not be understood.


##JSON-as-xml
The plugin supports a 'cheap' method of supporting both json and xml representation, while only requiring JSON marshallers/extractors to be created.  For producing messages, a custom media type mapped to a format that start with xml will use json to xml conversion as follows:

* The plugin will first convert the xml format to the equivalent json by means of convent.  For example, xmlv0 becomes jsonv0.
* The plugin then uses the json marshaller chain for that format to produce a JSON resource representation.
* The plugin then parses the json representation into a JSONObject, then uses the marshaller chain for the xml format to render the JSONObject as xml.

The plugin includes a JSONObjectMarshaller designed to convert a JSONObject to xml in a consistent manner.  Note that it is not possible to achieve a 1-to-1 mapping between JSON an xml.  For example, JSON allows backspaces and form-feeds to be encoded, while these characters are illegal in xml 1.0.

For requests, the plugin will treat any request with a format starting with xml (for the Content-Type) as json-as-xml, and will reverse the process:

* First, it will parse the xml content and construct a JSONObject from it.
* Then, it will look for a JSON extractor for the equivalent json format (e.g., if the Content-Type was xmlv0, it will look for an extractor for jsonv0)

The json-as-xml support is not intended as a complete replacement for custom xml marshallers and extractors, but could be used in situations where xml support is required, but clients can understand 'json-like' semantics, but are using an xml parser/marshaller toolkit.

##Service layer contract
The plugin delegates to the following methods on a service:

* list
* show
* create
* update
* delete

###list method
The list method will be passed the request parameters object directly.
If paging support is being used, params.max, and params.offset should be used to indicate the maximum number of results to return and the offset.

The list method must return a map containing the the following entries:

* instances: a collection of the objects for the resource being listed.  These objects will be rendered as a resource representation via the configured marshallers
* totalCount: the total count of all instances

###show method
The show method will be passed the request parameters object directly.
It must return a map containing the following entries:

* instance: the object for the resource being shown.  This object will be rendered as a resource representation via the configured marshallers

###create method
The create method is passed a Map extracted from the request.  (The map is generated by the Extractor registered for the resource and format.)
The create method is responsible for using the map to create a new instance of the resource.  For domain services, it is recommended that the extractor produce a map that will work with data binding, e.g., the create method is passed a Map params, and can create a new object as

`new Thing( params )`

The create method must return a Map containing the following entries:

* instance: the object representing the resource that was created.

###update method
The update method is passed a map having two entries:

* id: the key of the instance being updated
* content: a map of properties to be updated (as returned from an extractor)

For domain services, it is recommended that the extractor produce a map that will work with data binding, e.g., the object can be updated by

`thing.properties = params.content`

The update method is responsible for returning a map containing the following entries:

* instance: the updated object to be used to render a response

###delete method
The delete method is passed a map having two entries:

* id: the key of the instance to delete
* content: (optionally) a map of parameters for the object to delete.  Note that the only real reason to provide content is to support version checking, if for some reason delete in the application must do optimistic lock checking

The method currently returns an (empty) map, but this will probably be changed to void soon.

##Supplemental data/affordances/HATEOS
Since the plugin does not use an envelope in the message body, any affordances must be present in the resource representations themselves.

The exact method of support is still being researched.  Current thinking is that supplemental data will be provided to the marshallers via meta-programming on the instance returned from a service method.  For example, consider a 'Thing' service, which needs to provide supplemental data on an object by computing a sha1 hash of several fields:

`MessageDigest digest = MessageDigest.getInstance("SHA1")
digest.update("code:${thing.getCode()}".getBytes("UTF-8"))
digest.update("description${thing.getDescription()}".getBytes("UTF-8"))
def properties = [sha1:new BigInteger(1,digest.digest()).toString(16).padLeft(40,'0')]
thing.metaClass.getSupplementalRestProperties << {-> properties }`

Note that the getSupplementalRestProperties method is being added only to the single object instance, not the entire class.  A marshaller can check to see whether the instance it is marshalling support the method, and if so, extract data from it to generate affordances.

##Exception handling
When an exception is encountered while servicing a request, the controller will classify the exception into one of the following existing categories:

* ApplicationException
* OptimisticLockException
* Validation Exception
* UnsupportedRequestRepresentationException
* UnsupportedResponseRepresentationException
* AnyOtherException

Each one of these categories has a registered handler that specifies the status code to return, along with any additional headers or response body.

Except for the ApplicationException category, the other categories represent hard-coded responses mapped to exceptions as follows:

* OptimisticLockException: if the exception is an instance of org.springframework.dao.OptimisticLockingFailureException
* Validation Exception: if the exception is an instance of grails.validation.ValidationException
* UnsupportedRequestRepresentationException: internal exception thrown when a request  specifies a Content-Type that cannot be supported
* UnsupportedResponseRepresentationException: internal exception thrown when a request specifies a media type in the Accept header that cannot be supported.
* AnyOtherException: encountered an exception that doesn't fit any other category.  Will result in a 500 status

###ApplicationException
The ApplicationException is treated as a special case that allows applications using the plugin to customize how their exceptions map to response codes.

An ApplicationException is not determined by inheritance; instead duck typing is used.  If the controller encounters an exception that responds to 'getHttpStatusCode' (it has a method getHttStatusCode()) and has a property named 'returnMap' that is an instance of Closure, then the controller will treat that exception as an ApplicationException, and extract data from it as follow:

* getHttpStatusCode() will be invoked to obtain the http status code that should be returned
* the returnMap closure will be invoked, passing in a localizer so that localized messages can be contructed.  The closure must return a Map; entries in the map will be used as follows:
    * if the map contains a 'headers' key, the value is expected to be a map of header names/header values to return in the error response
    * if the map contains a 'message' key, the value is expected to be a (localized) string to be returned in the X-hedtech-message header.
    * if the map contains an 'errors' key, the value is expected to be an object that is to be rendered as JSON or xml in the response body

This definition of ApplicationException allows any application to customize error handling without extending or overriding any controller methods.  However, the implementation of any application exceptions must take responsibility for conforming to the strategy guide.  For example, if an application exception represents a validation exception, it needs to return a 400 status code, and should also return an 'X-Status-Reason:Validation failed' header.

Also note that the contract on what to recognize as an application exception was chosen to be compatible with the existing Banner Core ApplicationException.












