<!-- ********************************************************************
     Copyright 2013 Ellucian Company L.P. and its affiliates.
******************************************************************** -->

# TODO list for work (potential Jiras)
* Check the pageOffset and maxSize computations and ensure they are correct
* Work out the rules for Accept and Content-Type headers when the request or response body is empty.
* Make sure a 406 or 415 is returned for a resource not explicitly whitelisted
* Move the date marshaller for JSON into the explicit config, and out of the RestfulApiGrailsPlugin initialization
* If the selected representation has marshalling errors, fallback to other representations?
* What's the scope of a resource name?  Is it considered scoped within the application that exposes it?

# JSON-P support
* any impact to error handling?
* only valid for GET, so limited to list and show operations
* how to invoke?  use of callback parameter in combination with a json media type?  Is this acceptable as the actual return type
is not actually indicated by the media type?  (The media type applies to the wrapped content)


# TODO list (too small for JIRA)

# Code cleanup tasks
* Remove unused codes from message.properties
* Do the default messages belong in the plugin message.properties, since they are used by the plugin, and not the test app?
* Remove OptimisticLock exception support.

# Things to consider (may need user stories)
* Define strategy and guidelines for retaining version-specific representations. Can the general marshallers be used at all?  If so, are tests sufficient to drive develpment of version-specific marshallers?  Need discussion, and Shane input...
* Firm up contract with service create() method (what is returned in the result, optional id only, etc)
* Firm up contract with service create, update, and delete methods.  Do they get the full request params, or only the extracted resource representation?
* Support for Date binding.  Investigate grails.converters.json.date = 'javascript'
* Do we need to pass the type of action to the error handlers, in order to generate more specific error messages?
* The support for ApplicationException passes in a localizer, but not the name of the resource.  This prevents messages generated by ApplicationException from referring to resource names (it will have to generate messages for domain names).  Change contract with ApplicationException to pass in both a localizer, and the localized resource name?
* Generic JSON representation in XML does not check for JSON property names that are invalid in xml (contain whitespace, etc)
* Generic JSON representation in XML may need a meta-data driven facility to map JSON property names to different xml names
* Generic JSON representation in XML may need type information on literals?
* Generic JSON representation in XML may need a schema for the xml representation defined (so clients can use data-binding tools on the JSON as xml schema)?
* JSONObjectMarshaller: handling needed for special characters in strings? (e.g. backspace, tab, etc)
* JSONObjectMarshaller is using the entity <array> and <arrayElement> for a specific purpose, meaning that problems will be encountered rendering objects that use those as property names.  The ideal way to handle this would be to use a namespace, however, the grails xml converter does not support namespaces.


# Code review items
* Changed 409 responses to not have an error block.  You already know the requested resource, and the 409 response communicates that it's an optimistic lock.  An error block would be redundant information.
* Code review of ApplicationException support.

# Deficiencies in json-as-xml marshalling.
* JSON support \b and \f (backspace and form-feed) as legal string values.  XML 1.0 does not.  Converting a JSON entity that contains these will produce XML that cannot be parsed.
* JSON support \n, \r, and \t as explicit representations of newline, carriage return, and horizontal tab.  While this does not create unparsable xml, it does create xml that is not true to the original JSON meaning.  For example, a JSON entity {text:"\n"} has an explicit newline for the text field.  The corresponding xml is <text/>, which is either null or an empty string depending on how you interpret it.  A round trip in this case does not get you back at the same JSON you started with.  However {text:"a\nb"} will result in a sucessful roundtrip, as the conversion to XML will have a newline between the two characters.  The same is true for carriage returns and horizontal tabs.  Furthermore, XML 1.0 processor rules will cause "a\rb" to be parsed as "a\nb".




