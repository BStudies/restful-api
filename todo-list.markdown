<!-- ********************************************************************
     Copyright 2013 Ellucian Company L.P. and its affiliates.
******************************************************************** -->

# TODO list for work (potential Jiras)
* Nail down using map to pass data to the services, and issues with data binding.
* Check the pageOffset and maxSize computations and ensure they are correct
* Work out the rules for Accept and Content-Type headers when the request or response body is empty.

# TODO list (too small for JIRA)

# Code cleanup tasks
* Remove unused codes from message.properties
* Do the default messages belong in the plugin message.properties, since they are used by the plugin, and not the test app?
* Remove OptimisticLock exception support.

# Things to consider (may need user stories)
* Define strategy and guidelines for retaining version-specific representations. Can the general marshallers be used at all?  If so, are tests sufficient to drive develpment of version-specific marshallers?  Need discussion, and Shane input...
* Firm up contract with service save() method (what is returned in the result, optional id only, etc)
* Firm up contract with service save, update, and delete methods.  Do they get the full request params, or only the extracted resource representation?
* Support for Date binding.  Investigate grails.converters.json.date = 'javascript'
* Do we need to pass the type of action to the error handlers, in order to generate more specific error messages?
* The support for ApplicationException passes in a localizer, but not the name of the resource.  This prevents messages generated by ApplicationException from referring to resource names (it will have to generate messages for domain names).  Change contract with ApplicationException to pass in both a localizer, and the localized resource name?
* Generic JSON representation in XML does not check for JSON property names that are invalid in xml (contain whitespace, etc)
* Generic JSON representation in XML may need a meta-data driven facility to map JSON property names to different xml names
* Generic JSON representation in XML may need type information on literals?
* Generic JSON representation in XML may need a schema for the xml representation defined (so clients can use data-binding tools on the JSON as xml schema)?
* JSONObjectMarshaller: handling needed for special characters in strings? (e.g. backspace, tab, etc)
* JSONObjectMarshaller is using the entity <array> and <arrayElement> for a specific purpose, meaning that problems will be encountered rendering objects that use those as property names.  The ideal way to handle this would be to use a namespace, however, the grails xml converter does not support namespaces.
* Plugin is always using default JSON or XML (json-as-xml) marshalling if an error response is returned.  Is this correct?
* Starting to run into issues with relying on grails media type handling.  If an unsupported representation is requested, we probably want to
* return a 400 response, with appropriate headers and error messages indicating an unsupported representation was either sent or requested.
* However, by delegating to grails to get the format from the Accept-Header, we run into Grails attempt to make a best-effort substitution.  (For example, requesting an unknown media type will set response.format to 'html').  It appears grails will also give precedence to mediate types sepcified in the url or query parameter.


# Code review items
* Changed 409 responses to not have an error block.  You already know the requested resource, and the 409 response communicates that it's an optimistic lock.  An error block would be redundant information.
* Changes to message generation
* Code review of ApplicationException support.
* Why do we need selectFormat()?  it seems disconnected, as we have already selected format within the case statement.
* JSON-as-xml depends on the formats mapped to mime-types be xmlvX and jsonvX
* Current implementation of JSON-as-xml uses a custom marshaller for JSONObject that is registered under the named config for the format.

# Deficiencies in json-as-xml marshalling.
* JSON support \b and \f (backspace and form-feed) as legal string values.  XML 1.0 does not.  Converting a JSON entity that contains these will produce XML that cannot be parsed.
* JSON support \n, \r, and \t as explicit representations of newline, carriage return, and horizontal tab.  While this does not create unparsable xml, it does create xml that is not true to the original JSON meaning.  For example, a JSON entity {text:"\n"} has an explicit newline for the text field.  The corresponding xml is <text/>, which is either null or an empty string depending on how you interpret it.  A round trip in this case does not get you back at the same JSON you started with.  However {text:"a\nb"} will result in a sucessful roundtrip, as the conversion to XML will have a newline between the two characters.  The same is true for carriage returns and horizontal tabs.  Furthermore, XML 1.0 processor rules will cause "a\rb" to be parsed as "a\nb".

# Current Status
* Created an initial plugin project and test-app (that uses an in-memory database versus a Banner dependency)
* Partially implemented a generic controller with content negotiation that selects a registered marshaller. (Only show/list are implemented.)
* Implemented a generic 'basic' marhsaller, and a placeholder for a generic 'HAL' marshaller
* Implemented a trivial resource-specific marshaller
* Implemented initial functional test to prove use of various marshallers
* Implemented support for converting urls to resource names (e.g., part-of-things ==> PartOfThing) that leverages the 'inflector' plugin
* Demonstrate use of resource-specific marshallers (versus generic ones).
* Implement create/update/delete actions
* Support localization of label/title affordances (just use 'message' injected into the controller)
* Encapsulate the Inflector plugin within our own 'Inflector' class that exposes static methods (versus letting marshallers use the Inflector plugin directly)




