<!-- ********************************************************************
     Copyright 2013 Ellucian Company L.P. and its affiliates.
******************************************************************** -->

# TODO list for work (potential Jiras)
* Check the pageOffset and maxSize computations and ensure they are correct
* Work out the rules for Accept and Content-Type headers when the request or response body is empty.
* Move the date marshaller for JSON into the explicit config, and out of the RestfulApiGrailsPlugin initialization
* If the selected representation has marshalling errors, fallback to other representations?
* What's the scope of a resource name?  Is it considered scoped within the application that exposes it?

# JSON-P support
* any impact to error handling?
* only valid for GET, so limited to list and show operations
* how to invoke?  use of callback parameter in combination with a json media type?  Is this acceptable as the actual return type
is not actually indicated by the media type?  (The media type applies to the wrapped content)

# Thoughts on making marshalling easier
* Associations: recommend that object associations are exposed via references only if versioning is being used.  (That is, don't expose attributes
of an associated object in the object holding the association for example.)  Otherwise, when a new field is added to the referenced object, you have to add a new media-type/marshaller/extractor for the resource holding the association.  If the resource holding the association only exposes the reference (just expose id), then a caller can get the IDs, then get that particular resource with a show, controlling what version to retrieve.
* Need tools to generate what the entire marshaller/extractor chain looks like so you can see all the representations for a resource and how all classes are marshalled?
* Extractor chain does not have a heirarchy like marshalling.  Need one?  Probably can't as there is no class information incoming on which to construct the heirarchy.  Another reason to limit resource representation complexity by limiting association representation to id and no other attributes.
* Should warn users that if they create representations of associations that aren't simple references, then on create/update they have to deal with making the service layer smart enough to create/update associated objects as needed.


# TODO list (too small for JIRA)

# Code cleanup tasks
* Remove unused codes from message.properties
* Remove OptimisticLock exception support.

# Things to consider (may need user stories)
* Define strategy and guidelines for retaining version-specific representations. Can the general marshallers be used at all?  If so, are tests sufficient to drive develpment of version-specific marshallers?  Need discussion, and Shane input...
* Firm up contract with service create() method (what is returned in the result, optional id only, etc)
* Firm up contract with service create, update, and delete methods.  Do they get the full request params, or only the extracted resource representation?
* Support for Date binding.  Investigate grails.converters.json.date = 'javascript'
* Do we need to pass the type of action to the error handlers, in order to generate more specific error messages?
* The support for ApplicationException passes in a localizer, but not the name of the resource.  This prevents messages generated by ApplicationException from referring to resource names (it will have to generate messages for domain names).  Change contract with ApplicationException to pass in both a localizer, and the localized resource name?
* Generic JSON representation in XML does not check for JSON property names that are invalid in xml (contain whitespace, etc)
* Generic JSON representation in XML may need a meta-data driven facility to map JSON property names to different xml names
* Generic JSON representation in XML may need type information on literals?
* Generic JSON representation in XML may need a schema for the xml representation defined (so clients can use data-binding tools on the JSON as xml schema)?
* JSONObjectMarshaller: handling needed for special characters in strings? (e.g. backspace, tab, etc)
* JSONObjectMarshaller is using the entity <array> and <arrayElement> for a specific purpose, meaning that problems will be encountered rendering objects that use those as property names.  The ideal way to handle this would be to use a namespace, however, the grails xml converter does not support namespaces.


# Code review items
* Changed 409 responses to not have an error block.  You already know the requested resource, and the 409 response communicates that it's an optimistic lock.  An error block would be redundant information.
* Code review of ApplicationException support.

# Deficiencies in json-as-xml marshalling.
* JSON support \b and \f (backspace and form-feed) as legal string values.  XML 1.0 does not.  Converting a JSON entity that contains these will produce XML that cannot be parsed.
* JSON support \n, \r, and \t as explicit representations of newline, carriage return, and horizontal tab.  While this does not create unparsable xml, it does create xml that is not true to the original JSON meaning.  For example, a JSON entity {text:"\n"} has an explicit newline for the text field.  The corresponding xml is <text/>, which is either null or an empty string depending on how you interpret it.  A round trip in this case does not get you back at the same JSON you started with.  However {text:"a\nb"} will result in a sucessful roundtrip, as the conversion to XML will have a newline between the two characters.  The same is true for carriage returns and horizontal tabs.  Furthermore, XML 1.0 processor rules will cause "a\rb" to be parsed as "a\nb".




