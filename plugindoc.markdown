<!-- ********************************************************************
     Copyright 2013 Ellucian Company L.P. and its affiliates.
******************************************************************** -->

#RESTful API plugin documentation

##Overview
The restful-api plugin is an implementation designed to conform to the Ellucian API Strategy Document.  It is not intended to implement all optional features of the Document.  It is not intended to provide support for multiple ways to accomplish the same requirements; in general, it implements the recommended approaches specified in the document.

##Details

###Use of conventions
The plugin relies heavily on convention-over-configuration.  A request to a resource named 'things' will be delegated to the 'ThingService'.  De-pluralization of the resource name happens automatically; it is also assumed that there is unique ThingService that can be looked up in the grails application.

###Use of custom media types
The plugin relies on custom media types to specify resource representations.  For requests, the media type in the Content-Type header is used to identify the resource representation in the request body, in order to extract parameters from it to be passed to the resource's service.

Media types used must contain either 'json' or 'xml' in their name.  Any media type with 'json' in the name denotes a format that can be parsed as JSON; any type with 'xml' in the name is a format that is assumed to be parsed as XML.

###Media type of responses
For anything except a 500 response, the plugin will always return a Content-Type header of either 'application/xml' or 'application/json'.  This is intended as a convenience to viewing responses in browsers or other tools without having to configure them for all custom media types used by an API.  You can think of it as the Content-Type of the response identifies the format of the response body, but not the specific type of the representation contained within.

Responses generated by the plugin will always include a 'X-hedtech-Media-Type' header specifying the (versioned) media-type of the representation, e.g., 'application/vnd.hedtech.v0+json' or 'application/vnd.hedtech.minimal-thing.v0+xml'.  Consumers of the API can use the X-hedtech-Media-Type header to determine how to perform data binding on the resource representation returned.

###Media type of error responses
If a request results in an error response, the Media Type will always be 'application/json' or 'application/xml', based on whether the Accept header in the request specified an xml or json format.  If the Accept header could not be understood to request json or xml, then 'application/json' will be used for any data in the return body.

Errors are not considered part of the resource representation, and do not have versioned or custom representations.

###Media type of requests
The plugin uses the Content-Type header to determine the type of the resource representation sent in a request.  It uses the (first) Accept header to determine the type of resource representation that should be used in the response.  The Content-Type and Accept headers on a request are not required to match.

###Unsupported media types
If a request specified an unsupported media type in either the Content-Type or Accept header, the plugin will return a 400 response with an additional 'X-Status-Reason' header having a value of 'Unknown resource representation'  (This may change to a different status code in the future to clearly indicate that an unsupported media type was sent or requested if the Strategy Document specifies such a code.)

###Response envelope.
The plugin currently uses a thin 'envelope' in which the response body contains not the resource representation, but an envelope containing the representation, a message, and optional affordances.  However, work is being done to eliminate the envelope so that the message (or additional information) will be carried in headers, and the affordances will be made part of the resource representation.  The driver for this is to simplify custom xml representation marshalling.

##JSON-as-xml
The plugin supports a 'cheap' method of supporting both json and xml representation, while only requiring JSON marshallers/extractors to be created.